package gyremock.gen.scaladsl

import scala.collection.immutable

import akka.grpc.gen.{CodeGenerator, Logger}
import akka.grpc.gen.CodeGenerator.ScalaBinaryVersion
import akka.grpc.gen.scaladsl.{Method, ScalaCodeGenerator, Service}
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse
import gyremock.gen.BuildInfo
import protocbridge.Artifact
import scalapb.compiler._

/** this generates the code for the translation from grpc to wiremock http json */
object TranslatorCodeGen extends ScalaCodeGenerator {
  override val name: String = "translator"

  override def perServiceContent: Set[(Logger, Service) => immutable.Seq[CodeGeneratorResponse.File]] =
    super.perServiceContent + generateTranslateImpl

  private val generateTranslateImpl: (Logger, Service) => immutable.Seq[CodeGeneratorResponse.File] =
    (logger, service) => {
      val b = CodeGeneratorResponse.File.newBuilder()
      b.setContent(new TranslateCodeGenerator(service).run())
      b.setName(s"${service.packageDir}/${service.name}Translate.scala")
      logger.info(s"Generating Akka gRPC translation service impl for ${service.packageName}.${service.name}")
      immutable.Seq(b.build)
    }

  override def suggestedDependencies: ScalaBinaryVersion => Seq[Artifact] =
    (scalaBinaryVersion: CodeGenerator.ScalaBinaryVersion) =>
      super.suggestedDependencies(scalaBinaryVersion) ++ Seq(
        Artifact(
          BuildInfo.organization,
          BuildInfo.runtimeArtifactName + "_" + scalaBinaryVersion.prefix,
          BuildInfo.version
        )
      )
}

final private class TranslateCodeGenerator(service: Service) {
  def run(): String = {
    new FunctionalPrinter()
      .add("// Generated by the Scala Gyremock Plugin for the Protocol Buffer Compiler")
      .add("// Do not edit!")
      .newline
      .add(s"package ${service.packageName}")
      .newline
      .call(addImports)
      .newline
      .add(
        s"class ${service.name}Translate(grpcFromToJson: GrpcFromToJson)(implicit sys: ActorSystem) extends ${service.name} {"
      )
      .indent
      .add("private implicit val ec: ExecutionContext = sys.dispatcher")
      .newline
      .print(service.methods)(addMethodImpl)
      .outdent
      .add("}")
      .result
  }

  private def addImports(printer: FunctionalPrinter): FunctionalPrinter = {
    val libraryImports = immutable.Seq(
      "scala.concurrent.ExecutionContext",
      "io.github.touchdown.gyremock.GrpcFromToJson",
      "akka.actor.ActorSystem",
      "akka.stream.scaladsl._"
    )
    printer.add(libraryImports.map(i => s"import $i"): _*)
  }

  private def addMethodImpl(printer: FunctionalPrinter, method: Method): FunctionalPrinter = {
    printer
      .add(s"def ${method.nameSafe}(in: ${method.parameterType}): ${method.returnType} = {")
      .addIndented(method.methodType match {
        case akka.grpc.gen.Unary =>
          s"""grpcFromToJson.unary[${method.parameterType}, ${method.outputTypeUnboxed}](in, "/${service.name}/${method.name}")"""
        case akka.grpc.gen.ServerStreaming =>
          s"""Source.future(grpcFromToJson.sStream[${method.parameterType}, ${method.outputTypeUnboxed}](in, "/${service.name}/${method.name}")).mapConcat(identity)"""
        case akka.grpc.gen.ClientStreaming =>
          s"""in.runWith(Sink.seq).flatMap(e => grpcFromToJson.cStream[${method.inputTypeUnboxed}, ${method.outputTypeUnboxed}](e, "/${service.name}/${method.name}"))"""
        case akka.grpc.gen.BidiStreaming =>
          s"""in.mapAsync(1)(e => grpcFromToJson.unary[${method.inputTypeUnboxed}, ${method.outputTypeUnboxed}](e, "/${service.name}/${method.name}"))"""
      })
      .add("}")
      .newline
  }
}
